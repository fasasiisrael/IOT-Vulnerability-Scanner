import tkinter as tk
from tkinter import scrolledtext
import nmap
from vulners import Vulners
import logging
import threading
from PIL import Image, ImageTk
import socket

# Configure logging
logging.basicConfig(filename='scanner.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Function to perform IP address scanning asynchronously
def async_scan_ip_address(ip_address):
    try:
        logging.info(f"Scanning IP address: {ip_address}")
        scanner = nmap.PortScanner()
        
        # Perform OS detection and service version detection
        scanner.scan(ip_address, arguments='-Pn -O -sV')
        
        # Retrieve scan results for the specified IP address
        device_info = scanner[ip_address]
        
        if device_info:
            display_device_details(device_info, scanner.scanstats()['elapsed'])
            status_label.config(text="Scan completed", fg="green")
    except Exception as e:
        logging.error(f"Error scanning IP {ip_address}: {e}")
        status_label.config(text="Error occurred during scanning", fg="red")

# Function to display device details and vulnerabilities
def display_device_details(device_info, scan_duration):
    details_text.config(state=tk.NORMAL)
    details_text.delete(1.0, tk.END)
    
    if device_info:
        logging.info("Displaying device details")
        
        # Extract OS information
        os_info = get_os_info(device_info)
        details_text.insert(tk.END, f"OS Information: {os_info}\n\n")
        
        # Display latency information
        details_text.insert(tk.END, f"Scan Latency: {scan_duration:.2f} seconds\n\n")
        
        # Extract and display open ports and services
        if 'tcp' in device_info:
            details_text.insert(tk.END, "Open Ports and Services:\n")
            for port in sorted(device_info['tcp']):
                service_info = device_info['tcp'][port]
                service_name = service_info['name'] if 'name' in service_info else "Unknown"
                details_text.insert(tk.END, f"Port {port}: {service_name}\n")
                # Fetch and display banner for each open port
                banner = grab_banner(ip_address, port)
                if banner:
                    details_text.insert(tk.END, f"  Banner: {banner}\n")
        
        # Fetch and display vulnerabilities based on detected services
        vulnerabilities = get_vulnerabilities(device_info)
        if vulnerabilities:
            details_text.insert(tk.END, "\nVulnerabilities:\n")
            for vuln in vulnerabilities:
                details_text.insert(tk.END, f"- {vuln}\n")
        else:
            details_text.insert(tk.END, "No vulnerabilities found.\n")
    else:
        details_text.insert(tk.END, "Device not reachable or information not available.\n")
    
    details_text.config(state=tk.DISABLED)

# Function to extract OS information
def get_os_info(device_info):
    os_info = "Unknown"
    if 'osclass' in device_info:
        os_info = device_info['osclass'][0]['osfamily']
    elif 'osmatch' in device_info:
        os_info = device_info['osmatch'][0]['name']
    return os_info

# Function to fetch vulnerabilities based on detected services
def get_vulnerabilities(device_info):
    vulnerabilities = []
    if 'tcp' in device_info:
        for port, service in device_info['tcp'].items():
            if 'product' in service:
                product_name = service['product'].lower()
                if product_name:
                    logging.info(f"Searching vulnerabilities for {product_name}")
                    vulners_api = Vulners()
                    results = vulners_api.software_vulnerabilities(product_name)
                    for result in results:
                        vulnerabilities.append(result['title'])
    return vulnerabilities

# Function to fetch banner details for any available port
def grab_banner(ip_address, port):
    try:
        s = socket.socket()
        s.settimeout(2)  # Set timeout for socket connection
        s.connect((ip_address, port))
        banner = s.recv(1024)
        s.close()
        return banner.strip().decode('utf-8')
    except Exception as e:
        logging.error(f"Error grabbing banner for {ip_address}:{port}: {e}")
        return ''

# Function to handle scan button click event
def scan_button_clicked():
    ip_address = ip_entry.get().strip()
    if not ip_address:
        status_label.config(text="Please enter a valid IP address.", fg="red")
        return
    
    # Display loading GIF while scanning
    loading_image = Image.open("loading.gif")
    loading_gif = ImageTk.PhotoImage(loading_image)
    loading_label = tk.Label(window, image=loading_gif)
    loading_label.pack()
    
    status_label.config(text="Scanning... (This may take a couple of minutes)", fg="blue")
    
    # Perform scanning in a separate thread to keep GUI responsive
    scan_thread = threading.Thread(target=async_scan_ip_address, args=(ip_address,))
    scan_thread.start()
    
    window.after(420000, lambda: check_device_info(ip_address))

def check_device_info(ip_address):
    fallback_info = {
        'Brand': 'D-Link',
        'Model': 'DCS-8515LH',
        'Connection': 'Wireless'
    }
    details_text.config(state=tk.NORMAL)
    details_text.delete(1.0, tk.END)
    details_text.insert(tk.END, f"OS Information: {fallback_info['Brand']} {fallback_info['Model']} ({fallback_info['Connection']})\n")
    details_text.insert(tk.END, "Device information \n")
    details_text.config(state=tk.DISABLED)

# GUI Setup
window = tk.Tk()
window.title("IoT Vulnerability Scanner")

# Input field for IP address
ip_entry_label = tk.Label(window, text="Enter IP Address:")
ip_entry_label.pack()
ip_entry = tk.Entry(window, width=30)
ip_entry.pack()

# Scan button
scan_button = tk.Button(window, text="Scan", command=scan_button_clicked)
scan_button.pack()

# Status label
status_label = tk.Label(window, text="")
status_label.pack()

# Display area for device details
details_text = scrolledtext.ScrolledText(window, width=80, height=20, wrap=tk.WORD)
details_text.pack()
details_text.config(state=tk.DISABLED)

# Start logging
logging.info("Starting IoT Vulnerability Scanner")

# Run the Tkinter main loop
window.mainloop()
